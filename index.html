<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Campus Path Viewer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.min.js"></script>
    <link  rel="stylesheet" href="./styles.css" />
</head>
<body>
    <div class="container">
        <header>
            <div class="header-top">
                <button class="burger-menu" id="burger-menu">☰</button>
                <h1>Campus Path Viewer</h1>
            </div>
            <p class="subtitle">Visualize paths between campus locations</p>
        </header>
        
        <div class="content">
            <div class="viewer-container">
                <div id="canvas-container"></div>
                <div class="loading" id="loading">
                    <div class="spinner"></div>
                    <h3 id="loading-message">Loading Campus Data...</h3>
                    <p id="loading-submessage">Preparing path visualization</p>
                </div>
            </div>
        
            <div class="drawer-overlay" id="drawer-overlay"></div>
            
            <div class="controls" id="controls-drawer">
                <button class="close-drawer" id="close-drawer">✕</button>
                
                <div class="control-group">
                    <h2>Select Locations</h2>
                    
                    <div class="dropdown" id="from-dropdown">
                        <div class="dropdown-header">
                            <span id="from-dropdown-text">Select Start Location</span>
                            <span>▼</span>
                        </div>
                        <div class="dropdown-options" id="from-dropdown-options"></div>
                    </div>
                    
                    <div class="dropdown" id="to-dropdown">
                        <div class="dropdown-header">
                            <span id="to-dropdown-text">Select End Location</span>
                            <span>▼</span>
                        </div>
                        <div class="dropdown-options" id="to-dropdown-options"></div>
                    </div>
                    
                    <!-- <div class="btn-group">
                        <button id="show-path" class="btn primary">Show Path</button>
                        <button id="clear-path" class="btn danger">Clear Path</button>
                    </div> -->
                    
                    <div class="status-bar">
                        <div class="status-item">
                            <span class="status-label">Path Status:</span>
                            <span class="status-value" id="path-status">Not loaded</span>
                        </div>
                        <div class="status-item">
                            <span class="status-label">Distance:</span>
                            <span class="status-value" id="path-distance">0 meters</span>
                        </div>
                    </div>
                </div>
                
                <div class="control-group">
                    <h2>Navigation</h2>
                    <div class="btn-group">
                        <button id="walk-path" class="btn success">Walk Path</button>
                        <button id="reset-view" class="btn">Reset View</button>
                        <button id="fly-mode" class="btn warning">Fly Mode: Off</button>
                        <button id="show-camera" class="btn">Show Camera</button>
                    </div>
                    
                    <div class="status-bar">
                        <div class="status-item">
                            <span class="status-label">Progress:</span>
                            <span class="status-value" id="walk-progress">0%</span>
                        </div>
                        <div class="status-item">
                            <span class="status-label">Speed:</span>
                            <span class="status-value" id="walk-speed">Normal</span>
                        </div>
                        <div class="status-item">
                            <span class="status-label">Control Mode:</span>
                            <span class="status-value" id="control-mode">Orbit</span>
                        </div>
                    </div>
                </div>
                
                <div class="path-info">
                    <p>Paths are calculated based on predefined routes between campus locations. Select a start and end location to visualize the path.</p>
                </div>
            </div>
        </div>
    </div>

    <script type="module">
        // Main variables
        let scene, camera, renderer, controls;
        let model = null;
        let pathLine = null;
        let personModel = null;
        let isWalking = false;
        let walkingProgress = 0;
        let selectedFromPoint = null;
        let selectedToPoint = null;
        let currentPath = null;
        let lookoutIndicator = null;
        let isFlyMode = false;
        let lookAtPoint = new THREE.Vector3(0, 0, 0);
        
        // JSON data variables
        let CAMPUS_POINTS = {};
        let PREDEFINED_PATHS = {};
        
        let moveForward = false;
        let moveBackward = false;
        let moveLeft = false;
        let moveRight = false;
        let moveUp = false;
        let moveDown = false;
        let velocity = new THREE.Vector3();
        let direction = new THREE.Vector3();
        let speed = 5.0;
        
        // Initialize drawer functionality
        function initDrawer() {
            const burgerMenu = document.getElementById('burger-menu');
            const closeDrawer = document.getElementById('close-drawer');
            const drawer = document.getElementById('controls-drawer');
            const overlay = document.getElementById('drawer-overlay');

            function openDrawer() {
                drawer.classList.add('active');
                overlay.classList.add('active');
                burgerMenu.classList.add('active');
                document.body.style.overflow = 'hidden';
            }

            function closeDrawerFunc() {
                drawer.classList.remove('active');
                overlay.classList.remove('active');
                burgerMenu.classList.remove('active');
                document.body.style.overflow = '';
            }

            burgerMenu.addEventListener('click', openDrawer);
            closeDrawer.addEventListener('click', closeDrawerFunc);
            overlay.addEventListener('click', closeDrawerFunc);

            // Close drawer on escape key
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && drawer.classList.contains('active')) {
                    closeDrawerFunc();
                }
            });
        }

        // Initialize the scene
        async function init() {
            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0c0c1a);
            scene.fog = new THREE.Fog(0x0c0c1a, 10, 50);
            
            // Create camera
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 10, -15);
            
            // Create renderer
            renderer = new THREE.WebGLRenderer({ 
                antialias: true,
                alpha: true,
                logarithmicDepthBuffer: true
            });
            
            const container = document.getElementById('canvas-container');
            
            renderer.setSize(container.offsetWidth, container.offsetHeight);
            renderer.shadowMap.enabled = false;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            container.appendChild(renderer.domElement);
            
            // Add grid helper
            const gridHelper = new THREE.GridHelper(40, 20, 0x444466, 0x222244);
            gridHelper.position.y = -0.01;
            scene.add(gridHelper);
            
            // Lighting setup
            const ambientLight = new THREE.AmbientLight(0xffffff, 1.0);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 2.0);
            directionalLight.position.set(20, 30, 20);
            scene.add(directionalLight);
            
            const fillLight = new THREE.DirectionalLight(0xffffff, 1.5);
            fillLight.position.set(-20, 20, 20);
            scene.add(fillLight);
            
            // Add orbit controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = false;
            controls.maxDistance = 150;
            controls.minDistance = 2;
            controls.maxPolarAngle = Math.PI / 1.5;
            
            controls.target.set(0, 0, 0);
            controls.update();
            
            // Handle window resize
            window.addEventListener('resize', onWindowResize, false);
            
            // Initialize keyboard controls for fly mode
            initKeyboardControls();
            
            // Initialize UI components
            initDrawer();
            
            // Create person model
            createPersonModel();
            
            // Create lookout indicator
            createLookoutIndicator();
            
            // Load JSON data first
            await loadJSONData();
            
            
            // Load the model
            loadModel();
            
            // Initialize UI after data is loaded
            initUI();
        }
        
        // Initialize keyboard controls for fly mode
        function initKeyboardControls() {
            document.addEventListener('keydown', (event) => {
                if (!isFlyMode) return;
                
                switch (event.code) {
                    case 'KeyW': moveForward = true; break;
                    case 'KeyS': moveBackward = true; break;
                    case 'KeyA': moveLeft = true; break;
                    case 'KeyD': moveRight = true; break;
                    case 'KeyQ': moveUp = true; break;
                    case 'KeyE': moveDown = true; break;
                }
            });
            
            document.addEventListener('keyup', (event) => {
                if (!isFlyMode) return;
                
                switch (event.code) {
                    case 'KeyW': moveForward = false; break;
                    case 'KeyS': moveBackward = false; break;
                    case 'KeyA': moveLeft = false; break;
                    case 'KeyD': moveRight = false; break;
                    case 'KeyQ': moveUp = false; break;
                    case 'KeyE': moveDown = false; break;
                }
            });
        }
        
        async function loadJSONData() {
            try {
                updateLoadingMessage('Loading path data...');
                
               const response = await fetch('path.json');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const jsonData = await response.json();
                CAMPUS_POINTS = jsonData.locations;
                PREDEFINED_PATHS = jsonData.paths;
                
                updateLoadingMessage('Loading campus model...');
            } catch (error) {
                console.error('Error loading JSON data:', error);
                updateLoadingMessage('Error loading path data');
                document.getElementById('loading-submessage').textContent = error.message;
                
                // Create default data to prevent complete failure
                CAMPUS_POINTS = {
                    "Main Entrance": {x: 0, y: 0, z: 0},
                    "Library": {x: 5, y: 0, z: 5},
                    "Cafeteria": {x: -5, y: 0, z: 5}
                };
                
                PREDEFINED_PATHS = {
                    "Main_Entrance_Library": {
                        path: [
                            {x: 0, y: 0.1, z: 0},
                            {x: 2.5, y: 0.1, z: 2.5},
                            {x: 5, y: 0.1, z: 5}
                        ],
                        lookout: {position: [2.5, 3, 2.5], target: [0, 0, 0]}
                    }
                };
            }
        }
        
        function updateLoadingMessage(message) {
            const loadingMessage = document.getElementById('loading-message');
            if (loadingMessage) {
                loadingMessage.textContent = message;
            }
        }
        
        // Create lookout indicator
        function createLookoutIndicator() {
            const geometry = new THREE.SphereGeometry(0.1, 16, 16);
            const material = new THREE.MeshBasicMaterial({ 
                color: 0xff00ff,
                transparent: true,
                opacity: 0.8,
                wireframe: true
            });
            
            lookoutIndicator = new THREE.Mesh(geometry, material);
            lookoutIndicator.visible = false;
            scene.add(lookoutIndicator);
            
            // Add text label
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 256;
            canvas.height = 64;
            context.fillStyle = '#ffffff';
            context.font = '16px Arial';
            context.textAlign = 'center';
            context.fillText('LOOKOUT', 128, 40);

            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.position.set(0, 0.5, 0);
            sprite.scale.set(0.5, 0.125, 1);
            sprite.name = 'lookoutLabel';
            lookoutIndicator.add(sprite);
        }

        function initUI() {
            // Populate dropdowns
            const fromOptions = document.getElementById('from-dropdown-options');
            const toOptions = document.getElementById('to-dropdown-options');
            
            Object.keys(CAMPUS_POINTS).forEach(locationName => {
                // From dropdown
                const fromOption = document.createElement('div');
                fromOption.className = 'dropdown-option';
                fromOption.textContent = locationName;
                fromOption.dataset.value = locationName;
                fromOption.addEventListener('click', () => {
                    document.querySelectorAll('#from-dropdown .dropdown-option').forEach(opt => {
                        opt.classList.remove('selected');
                    });
                    fromOption.classList.add('selected');
                    document.getElementById('from-dropdown-text').textContent = locationName;
                    selectedFromPoint = locationName;
                    document.getElementById('from-dropdown').classList.remove('open');
                    
                    // Auto update camera when both points are selected
                    if (selectedFromPoint && selectedToPoint) {
                        moveCameraToLookout();
                    }
                });
                fromOptions.appendChild(fromOption);
                
                // To dropdown
                const toOption = document.createElement('div');
                toOption.className = 'dropdown-option';
                toOption.textContent = locationName;
                toOption.dataset.value = locationName;
                toOption.addEventListener('click', () => {
                    document.querySelectorAll('#to-dropdown .dropdown-option').forEach(opt => {
                        opt.classList.remove('selected');
                    });
                    toOption.classList.add('selected');
                    document.getElementById('to-dropdown-text').textContent = locationName;
                    selectedToPoint = locationName;
                    document.getElementById('to-dropdown').classList.remove('open');
                    highlightLocation(locationName);
                    
                    // Auto update camera when both points are selected
                    if (selectedFromPoint && selectedToPoint) {
                        moveCameraToLookout();
                        generatePath(); 
                    }
                });
                toOptions.appendChild(toOption);
            });
            
            // Dropdown toggle
            document.querySelectorAll('.dropdown-header').forEach(header => {
                header.addEventListener('click', function() {
                    const dropdown = this.parentElement;
                    dropdown.classList.toggle('open');
                });
            });
            
            // Button events
            document.getElementById('walk-path').addEventListener('click', startWalking);
            document.getElementById('reset-view').addEventListener('click', resetView);
            document.getElementById('fly-mode').addEventListener('click', toggleFlyMode);
        }

        function toggleFlyMode() {
            isFlyMode = !isFlyMode;
            const flyButton = document.getElementById('fly-mode');
            
            if (isFlyMode) {
                // Enable fly controls, disable orbit controls
                controls.enabled = false;
                flyButton.textContent = 'Fly Mode: On';
                flyButton.classList.add('primary');
                document.getElementById('control-mode').textContent = 'Fly';
            } else {
                // Enable orbit controls, disable fly controls
                controls.enabled = true;
                flyButton.textContent = 'Fly Mode: Off';
                flyButton.classList.remove('primary');
                document.getElementById('control-mode').textContent = 'Orbit';
            }
        }
        // Create person model
        function createPersonModel() {
            const personGroup = new THREE.Group();
            
            // Body
            const bodyGeometry = new THREE.CylinderGeometry(0.03, 0.04, 0.12, 8);
            const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0x4169E1 });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.06;
            personGroup.add(body);
            
            // Head
            const headGeometry = new THREE.SphereGeometry(0.025, 8, 6);
            const headMaterial = new THREE.MeshLambertMaterial({ color: 0xFFDBB5 });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 0.145;
            personGroup.add(head);
            
            // Arms
            const armGeometry = new THREE.CylinderGeometry(0.008, 0.008, 0.08, 6);
            const armMaterial = new THREE.MeshLambertMaterial({ color: 0xFFDBB5 });
            
            const leftArm = new THREE.Mesh(armGeometry, armMaterial);
            leftArm.position.set(-0.045, 0.08, 0);
            leftArm.rotation.z = 0.3;
            personGroup.add(leftArm);
            
            const rightArm = new THREE.Mesh(armGeometry, armMaterial);
            rightArm.position.set(0.045, 0.08, 0);
            rightArm.rotation.z = -0.3;
            personGroup.add(rightArm);
            
            // Legs
            const legGeometry = new THREE.CylinderGeometry(0.01, 0.01, 0.08, 6);
            const legMaterial = new THREE.MeshLambertMaterial({ color: 0x2F4F4F });
            
            const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
            leftLeg.position.set(-0.015, -0.04, 0);
            personGroup.add(leftLeg);
            
            const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
            rightLeg.position.set(0.015, -0.04, 0);
            personGroup.add(rightLeg);
            
            personModel = personGroup;
            scene.add(personModel);
        }
        
        // Highlight a location
        function highlightLocation(locationName) {
            // Remove any existing highlight
            const existingHighlight = document.querySelector('.location-highlight');
            if (existingHighlight) {
                existingHighlight.remove();
            }
            
            const point = CAMPUS_POINTS[locationName];
            if (!point) return;
            
            // Convert 3D position to screen position
            const vector = new THREE.Vector3(point.x, point.y + 0.5, point.z);
            vector.project(camera);
            
            const container = document.getElementById('canvas-container');
            const x = (vector.x * 0.5 + 0.5) * container.clientWidth;
            const y = (-vector.y * 0.5 + 0.5) * container.clientHeight;
            
            // Create highlight element
            const highlight = document.createElement('div');
            highlight.className = 'location-highlight';
            highlight.textContent = locationName;
            highlight.style.left = `${x}px`;
            highlight.style.top = `${y}px`;
            container.appendChild(highlight);
            
            // Remove highlight after delay
            setTimeout(() => {
                if (highlight.parentNode) {
                    highlight.parentNode.removeChild(highlight);
                }
            }, 2000);
        }
        
        // Move camera to lookout point
        function moveCameraToLookout() {
            if (!selectedFromPoint || !selectedToPoint) return;
            
            // Create path key in format "from_to"
            const pathKey = `${selectedFromPoint}_${selectedToPoint}`;
            const reversePathKey = `${selectedToPoint}_${selectedFromPoint}`;
            // Try to find predefined path
            let pathData = PREDEFINED_PATHS[pathKey] || PREDEFINED_PATHS[reversePathKey];
            // If we have a lookout point, use it for camera positioning
            if (pathData && pathData.lookout) {
                const lookout = pathData.lookout;
                
                // Position lookout indicator
                lookoutIndicator.position.set(lookout.position[0], lookout.position[1], lookout.position[2]);
                lookoutIndicator.visible = true;
                
                // Set the lookAt point
                lookAtPoint.set(lookout.target[0], lookout.target[1], lookout.target[2]);
                
                // Calculate camera position (offset from lookout)
                const cameraPosition = {
                    x: lookout.position[0],
                    y: lookout.position[1],
                    z: lookout.position[2]
                };
                
                // Animate camera to position and look at lookout
                animateCamera(
                    [cameraPosition.x, cameraPosition.y, cameraPosition.z],
                    [lookout.target[0], lookout.target[1], lookout.target[2]],
                    1000
                );
            } else {
                // No lookout - hide indicator
                lookoutIndicator.visible = false;
                
                // Move camera to start location
                const start = CAMPUS_POINTS[selectedFromPoint];
                const end = CAMPUS_POINTS[selectedToPoint];
                
                if (start && end) {
                    // Calculate midpoint between start and end
                    const midpoint = {
                        x: (start.x + end.x) / 2,
                        y: (start.y + end.y) / 2,
                        z: (start.z + end.z) / 2
                    };
                    
                    // Set the lookAt point
                    lookAtPoint.set(midpoint.x, midpoint.y, midpoint.z);
                    
                    // Calculate camera position (above midpoint)
                    const cameraPosition = {
                        x: midpoint.x + 3,
                        y: midpoint.y + 3,
                        z: midpoint.z + 3
                    };
                    
                    animateCamera(
                        [cameraPosition.x, cameraPosition.y, cameraPosition.z],
                        [midpoint.x, midpoint.y, midpoint.z],
                        1000
                    );
                }
            }
        }
        
        // Camera animation function
        function animateCamera(targetPosition, targetLookAt, duration = 1000) {
            const startPosition = camera.position.clone();
            const startTarget = controls.target.clone();
            const endPosition = new THREE.Vector3(...targetPosition);
            const endTarget = new THREE.Vector3(...targetLookAt);
            const startTime = Date.now();
            
            function updateCamera() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                // Smooth step
                const ease = progress < 0.5 
                    ? 4 * progress * progress * progress 
                    : 1 - Math.pow(-2 * progress + 2, 3) / 2;
                
                camera.position.lerpVectors(startPosition, endPosition, ease);
                controls.target.lerpVectors(startTarget, endTarget, ease);
                controls.update();
                
                if (progress < 1) {
                    requestAnimationFrame(updateCamera);
                }
            }
            
            requestAnimationFrame(updateCamera);
        }

        function generatePath() {
            if (!selectedFromPoint || !selectedToPoint) {
                alert('Please select both start and end locations');
                return;
            }
            
            if (selectedFromPoint === selectedToPoint) {
                alert('Start and end locations cannot be the same');
                return;
            }
            
            clearPath();
            
            // Create path key in format "from_to"
            const pathKey = `${selectedFromPoint}_${selectedToPoint}`;
            const reversePathKey = `${selectedToPoint}_${selectedFromPoint}`;
            
            let pathData = null;
            let path = null;
            let isReversed = false;
            
            // Try to find predefined path
            if (PREDEFINED_PATHS[pathKey]) {
                pathData = PREDEFINED_PATHS[pathKey];
                path = pathData.path;
                document.getElementById('path-status').textContent = 'Predefined path';
            } else if (PREDEFINED_PATHS[reversePathKey]) {
                pathData = PREDEFINED_PATHS[reversePathKey];
                path = [...pathData.path].reverse(); // Reverse the path array
                isReversed = true;
                document.getElementById('path-status').textContent = 'Predefined path (reversed)';
            } else {
                // Create a direct path as fallback
                const start = CAMPUS_POINTS[selectedFromPoint];
                const end = CAMPUS_POINTS[selectedToPoint];
                
                if (!start || !end) return;
                
                path = [
                    {x: start.x, y: start.y + 0.02, z: start.z},
                    {x: (start.x + end.x)/2, y: Math.max(start.y, end.y) + 1.0, z: (start.z + end.z)/2},
                    {x: end.x, y: end.y + 0.02, z: end.z}
                ];
                
                document.getElementById('path-status').textContent = 'Direct path';
            }
            
            // Create visualization
            if (path) {
                const pathCoordinates = path.map(p => new THREE.Vector3(p.x, p.y, p.z));
                
                const curve = new THREE.CatmullRomCurve3(pathCoordinates);
                const tubeGeometry = new THREE.TubeGeometry(curve, pathCoordinates.length * 2, 0.02, 8, false);
                const tubeMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0x00ff00,
                    transparent: true,
                    opacity: 0.9
                });
                
                pathLine = new THREE.Mesh(tubeGeometry, tubeMaterial);
                scene.add(pathLine);
                
                currentPath = pathCoordinates;
                
                // Calculate approximate distance
                const distance = Math.round(pathCoordinates.reduce((sum, point, i, arr) => {
                    if (i === 0) return sum;
                    return sum + point.distanceTo(arr[i-1]);
                }, 0) * 10);
                
                document.getElementById('path-distance').textContent = `${distance} meters`;
                
                // Position person at start
                personModel.position.copy(pathCoordinates[0]);
                
                // Use lookout for camera positioning if available
                if (pathData && pathData.lookout) {
                    const lookout = pathData.lookout;
                    lookoutIndicator.position.set(lookout.position[0], lookout.position[1], lookout.position[2]);
                    lookoutIndicator.visible = true;
                    console.log(lookout)
                    // Set the lookAt point
                    lookAtPoint.set(lookout.target[0], lookout.target[1], lookout.target[2]);
                    
                    // Calculate camera position (offset from lookout)
                    const cameraPosition = {
                        x: lookout.position[0],
                        y: lookout.position[1],
                        z: lookout.position[2]
                    };
                    
                    animateCamera(
                        [cameraPosition.x, cameraPosition.y, cameraPosition.z],
                        [lookout.target[0], lookout.target[1], lookout.target[2]],
                        1000
                    );
                } else {
                    lookoutIndicator.visible = false;
                    
                    // Move camera to start and look at end
                    const start = CAMPUS_POINTS[selectedFromPoint];
                    const end = CAMPUS_POINTS[selectedToPoint];
                    
                    if (start && end) {
                        // Calculate midpoint between start and end
                        const midpoint = {
                            x: (start.x + end.x) / 2,
                            y: (start.y + end.y) / 2,
                            z: (start.z + end.z) / 2
                        };
                        
                        // Set the lookAt point
                        lookAtPoint.set(midpoint.x, midpoint.y, midpoint.z);
                        
                        // Calculate camera position (above midpoint)
                        const cameraPosition = {
                            x: midpoint.x + 3,
                            y: midpoint.y + 3,
                            z: midpoint.z + 3
                        };
                        
                        animateCamera(
                            [cameraPosition.x, cameraPosition.y, cameraPosition.z],
                            [midpoint.x, midpoint.y, midpoint.z],
                            1000
                        );
                    }
                }
            }
        }

        function clearPath() {
            isWalking = false;
            walkingProgress = 0;
            
            if (pathLine) {
                scene.remove(pathLine);
                pathLine = null;
            }
            
            currentPath = null;
            lookoutIndicator.visible = false;
            document.getElementById('walk-progress').textContent = '0%';
            document.getElementById('path-status').textContent = 'No path shown';
            document.getElementById('path-distance').textContent = '0 meters';
        }

        function startWalking() {
            if (!currentPath || currentPath.length === 0) {
                alert('Please generate a path first');
                return;
            }
            
            isWalking = true;
            walkingProgress = 0;
            
            if (currentPath.length > 0) {
                personModel.position.copy(currentPath[0]);
            }
        }
        
        function resetView() {
            clearPath();
            camera.position.set(0, 10, -15);
            controls.target.set(0, 0, 0);
            controls.update();
            lookAtPoint.set(0, 0, 0);
        }

        // Load model
        function loadModel() {
            const loader = new THREE.GLTFLoader();
            const modelUrl = 'nwssu.glb';
            
            loader.load(
                modelUrl,
                (gltf) => {
                    model = gltf.scene;
                    
                    const bbox = new THREE.Box3().setFromObject(model);
                    const size = bbox.getSize(new THREE.Vector3());
                    
                    const maxDimension = Math.max(size.x, size.y, size.z);
                    const scale = 50 / maxDimension;
                    model.scale.setScalar(scale);
                    
                    model.traverse((child) => {
                        if (child.isMesh) {
                            child.castShadow = true;
                            child.receiveShadow = true;
                        }
                    });
                    
                    scene.add(model);
                    controls.target.set(0, 0, 0);
                    controls.update();
                    
                    document.getElementById('loading').classList.add('hidden');
                    renderer.render(scene, camera);
                },
                (xhr) => {
                    const percent = Math.round((xhr.loaded / xhr.total) * 100);
                    document.getElementById('loading-submessage').textContent = `Loading: ${percent}%`;
                },
                (error) => {
                    document.getElementById('loading').classList.add('hidden');
                    createPlaceholderModel();
                }
            );
        }
        
        function createPlaceholderModel() {
            const geometry = new THREE.BoxGeometry(15, 5, 15);
            const material = new THREE.MeshLambertMaterial({ 
                color: 0x888888,
                transparent: true,
                opacity: 0.8
            });
            
            model = new THREE.Mesh(geometry, material);
            model.position.set(0, 2.5, 0);
            model.castShadow = true;
            model.receiveShadow = true;
            
            scene.add(model);
        }
        
        function onWindowResize() {
            camera.aspect = document.getElementById('canvas-container').offsetWidth / document.getElementById('canvas-container').offsetHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(document.getElementById('canvas-container').offsetWidth, document.getElementById('canvas-container').offsetHeight);
        }
        
        function updateFlyControls(delta) {
            velocity.x -= velocity.x * 10.0 * delta;
            velocity.y -= velocity.y * 10.0 * delta;
            velocity.z -= velocity.z * 10.0 * delta;
            
            direction.z = Number(moveForward) - Number(moveBackward);
            direction.x = Number(moveRight) - Number(moveLeft);
            direction.y = Number(moveUp) - Number(moveDown);
            direction.normalize();
            
            if (moveForward || moveBackward) velocity.z -= direction.z * speed * delta;
            if (moveLeft || moveRight) velocity.x -= direction.x * speed * delta;
            if (moveUp || moveDown) velocity.y -= direction.y * speed * delta;
            
            camera.translateX(velocity.x * delta);
            camera.translateY(velocity.y * delta);
            camera.translateZ(velocity.z * delta);
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            const delta = 0.0167; // Approximate 60fps
            
            if (isFlyMode) {
                updateFlyControls(delta);
            } else {
                controls.update(); // Update orbit controls
            }
            
            // Animate person walking
            if (isWalking && currentPath && currentPath.length > 1) {
                walkingProgress += 0.005;
                
                if (walkingProgress >= 1) {
                    walkingProgress = 1;
                    isWalking = false;
                }
                
                const totalLength = currentPath.length - 1;
                const scaledProgress = walkingProgress * totalLength;
                const index = Math.floor(scaledProgress);
                const fraction = scaledProgress - index;
                
                if (index < currentPath.length - 1) {
                    const start = currentPath[index];
                    const end = currentPath[index + 1];
                    
                    personModel.position.lerpVectors(start, end, fraction);
                    
                    const direction = new THREE.Vector3().subVectors(end, start).normalize();
                    if (direction.length() > 0) {
                        personModel.lookAt(personModel.position.clone().add(direction));
                    }
                    
                    const bobOffset = Math.sin(Date.now() * 0.01) * 0.01;
                    personModel.position.y += bobOffset;
                    
                    document.getElementById('walk-progress').textContent = Math.round(walkingProgress * 100) + '%';
                }
            }
            
            renderer.render(scene, camera);
        }
        
        init();
        animate();
    </script>
</body>
</html>