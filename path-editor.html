<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Campus Path Editor & Navigator</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/PointerLockControls.js"></script>
    <link rel="stylesheet" href="./styles.css" />
    <style>
        /* Added styles for fly mode button in editor */
        .fly-mode-btn-container {
            margin-top: 12px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .fly-mode-btn-container .btn {
            margin-top: 8px;
        }
        
        .fly-mode-status {
            font-size: 0.8rem;
            color: #00dbde;
            margin-top: 5px;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <button class="burger-menu" id="burger-menu">☰</button>
            <h1>Campus Path Editor & Navigator</h1>
            <p class="subtitle">Create custom walkable paths and navigate using predefined routes</p>
        </header>
        
        <div class="content">
            <div class="viewer-container">
                <div id="canvas-container"></div>
                <!-- Crosshair for fly mode -->
                <div class="crosshair" id="crosshair"></div>
                
                <div class="loading" id="loading">
                    <div class="spinner"></div>
                    <h3>Loading Campus Model...</h3>
                    <p>Loading locations and preparing path editor...</p>
                </div>
                
                <!-- Fly Mode Controls -->
                <div class="fly-controls" id="fly-controls">
                    <button id="exit-fly-mode" class="fly-mode-btn">
                        <span>✕</span> Exit Fly Mode
                    </button>
                    <div class="fly-instructions">
                        <p>Use <span class="fly-key">W</span> <span class="fly-key">A</span> <span class="fly-key">S</span> <span class="fly-key">D</span> to move</p>
                        <p>Press <span class="fly-key">SPACE</span> to go up, <span class="fly-key">SHIFT</span> to go down</p>
                        <p>Move mouse to look around</p>
                        <p>Press <span class="fly-key">P</span> to record path points</p>
                        <p>Press <span class="fly-key">U</span> to undo last point</p>
                    </div>
                </div>
            </div>

            <!-- Drawer Overlay -->
            <div class="drawer-overlay" id="drawer-overlay"></div>
            
            <div class="controls" id="controls-drawer">
                <button class="close-drawer" id="close-drawer">✕</button>
                
                <!-- Data Load Status -->
                <div class="load-status" id="load-status">
                    <div class="status-item">
                        <span class="status-label">Data Status:</span>
                        <span class="status-value" id="data-load-status">Loading...</span>
                    </div>
                    <div class="status-item">
                        <span class="status-label">Locations:</span>
                        <span class="status-value" id="loaded-location-count">0</span>
                    </div>
                    <div class="status-item">
                        <span class="status-label">Paths:</span>
                        <span class="status-value" id="loaded-path-count">0</span>
                    </div>
                </div>

                <div class="control-group">
                    <h2>Mode Selection</h2>
                    <div class="mode-toggle">
                        <button id="navigate-mode" class="btn active">Navigate</button>
                        <button id="edit-mode" class="btn">Edit Paths</button>
                    </div>
                </div>

                <!-- Navigation Mode -->
                <div id="navigation-panel">
                    <div class="control-group">
                        <h2>Camera Positions</h2>
                        <div class="dropdown" id="dropdown">
                            <div class="dropdown-header">
                                <span id="dropdown-text">Select Position</span>
                                <span>▼</span>
                            </div>
                            <div class="dropdown-options" id="dropdown-options"></div>
                        </div>
                    </div>

                    <div class="control-group">
                        <h2>Navigation</h2>
                        <div id="auto-camera-notification" class="auto-camera-status" style="display: none;">
                            🎯 Camera will auto-move to start point
                        </div>
                        
                        <label style="font-size: 0.8rem; margin-bottom: 5px; display: block; color: #00dbde;">From:</label>
                        <div class="dropdown" id="from-dropdown">
                            <div class="dropdown-header">
                                <span id="from-dropdown-text">Select Start Point</span>
                                <span>▼</span>
                            </div>
                            <div class="dropdown-options" id="from-dropdown-options"></div>
                        </div>
                        
                        <label style="font-size: 0.8rem; margin-bottom: 5px; display: block; margin-top: 10px; color: #00dbde;">To:</label>
                        <div class="dropdown" id="to-dropdown">
                            <div class="dropdown-header">
                                <span id="to-dropdown-text">Select End Point</span>
                                <span>▼</span>
                            </div>
                            <div class="dropdown-options" id="to-dropdown-options"></div>
                        </div>
                        
                        <div class="control-buttons" style="margin-top: 12px;">
                            <button id="generate-path" class="btn primary">Generate Path</button>
                            <button id="clear-path" class="btn danger">Clear Path</button>
                        </div>
                    </div>

                    <div class="control-group">
                        <h2>Person Model</h2>
                        <div class="control-buttons">
                            <button id="walk-path" class="btn success">Walk Path</button>
                            <button id="reset-person" class="btn danger">Reset Person</button>
                        </div>
                        <div class="status-bar">
                            <div class="status-item">
                                <span class="status-label">Progress:</span>
                                <span class="status-value" id="walk-progress">0%</span>
                            </div>
                            <div class="status-item">
                                <span class="status-label">Height:</span>
                                <span class="status-value" id="person-height">0.00</span>
                            </div>
                            <div class="status-item">
                                <span class="status-label">Using:</span>
                                <span class="status-value" id="path-type">No path</span>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Path Editor Mode -->
                <div id="editor-panel" style="display: none;">
                    <div class="control-group">
                        <h2>Path Editor</h2>
                        <div class="instructions">
                            <h3>How to create paths:</h3>
                            <ul>
                                <li>Enter path name (use ID format like "1_2")</li>
                                <li>Click "Start Recording" to enter fly mode</li>
                                <li>Fly to points and press 'P' to record</li>
                                <li>Press 'U' to undo last point</li>
                                <li>Click "Save Path" when done</li>
                                <li>Export when finished</li>
                            </ul>
                        </div>
                        
                        <input type="text" id="path-name" class="path-input" placeholder="Enter path name (e.g., 1_2 for Lab to Tennis)">
                        
                        <div class="control-buttons">
                            <button id="start-recording" class="btn primary">Start Recording</button>
                            <button id="save-path" class="btn success">Save Path</button>
                            <button id="look-up" class="btn">Look Up</button>
                        </div>
                        
                        <div class="control-buttons">
                            <button id="clear-current" class="btn danger">Clear Current</button>
                            <button id="undo-point" class="btn">Undo Point</button>
                        </div>
                        
                        <div class="fly-mode-btn-container">
                            <button id="fly-mode" class="btn primary">Enter Fly Mode</button>
                            <div class="fly-mode-status" id="fly-mode-status">Fly Mode: Inactive</div>
                        </div>
                        
                        <div class="status-bar">
                            <div class="status-item">
                                <span class="status-label">Recording:</span>
                                <span class="status-value" id="recording-status">Stopped</span>
                            </div>
                            <div class="status-item">
                                <span class="status-label">Points:</span>
                                <span class="status-value" id="point-count">0</span>
                            </div>
                        </div>
                    </div>

                    <div class="control-group">
                        <h2>Saved Paths</h2>
                        <div class="path-list" id="path-list">
                            <p style="text-align: center; opacity: 0.6; padding: 20px; font-size: 0.8rem;">Loading paths...</p>
                        </div>
                        
                        <div class="control-buttons">
                            <button id="export-paths" class="btn primary">Export JSON</button>
                            <button id="import-paths" class="btn">Import JSON</button>
                        </div>
                        <input type="file" id="file-input" accept=".json" style="display: none;">
                        
                        <div class="control-buttons">
                            <button id="reload-data" class="btn">Reload Data</button>
                            <button id="show-all-paths" class="btn">Show All Paths</button>
                        </div>
                    </div>
                </div>
                
            </div>
        </div>
    </div>

    <script>
        // Main variables
        let scene, camera, renderer, controls;
        let model = null;
        let currentPath = null;
        let pathLine = null;
        let personModel = null;
        let isWalking = false;
        let walkingProgress = 0;
        let selectedFromPoint = null;
        let selectedToPoint = null;
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        
        // Path editor variables
        let isRecording = false;
        let currentRecordingPath = [];
        let recordingMarkers = [];
        let savedPaths = {};
        let isEditMode = false;
        let allPathLines = [];
        let lookAtIndicators = [];
        
        // Fly mode variables
        let flyControls = null;
        let isFlyMode = false;
        let moveForward = false;
        let moveBackward = false;
        let moveLeft = false;
        let moveRight = false;
        let moveUp = false;
        let moveDown = false;
        
        // Data from JSON
        let CAMPUS_POINTS = {};
        let LOCATION_ID_MAP = {};
        let PREDEFINED_PATHS = {};
        
        // Camera configurations
        const COORDINATES = {
            DEFAULT: { position: [0.7578, 4.6168, -6.4757], target: [12.8938, 2.2596, -5.5850] },
            CCIS: { position: [-11.4023, 3.1333, -6.5408], target: [-12.8938, 2.2596, -2.5850] },
            CRIM: { position: [-7.0789, 2.6126, -6.3270], target: [-12.8938, 2.2596, -5.5850] },
            COM: { position: [-1.5614, 5.0422, 0.7315], target: [12.8938, 2.2596, -5.5850] },
            DEFAULT2: { position: [-24.1283, 7.0082, -11.4318], target: [0.0000, 0.0000, 0.0000] }
        };

        // Initialize drawer functionality
        function initDrawer() {
            const burgerMenu = document.getElementById('burger-menu');
            const closeDrawer = document.getElementById('close-drawer');
            const drawer = document.getElementById('controls-drawer');
            const overlay = document.getElementById('drawer-overlay');

            function openDrawer() {
                drawer.classList.add('active');
                overlay.classList.add('active');
                burgerMenu.classList.add('active');
                document.body.style.overflow = 'hidden';
            }

            function closeDrawerFunc() {
                drawer.classList.remove('active');
                overlay.classList.remove('active');
                burgerMenu.classList.remove('active');
                document.body.style.overflow = '';
            }

            burgerMenu.addEventListener('click', openDrawer);
            closeDrawer.addEventListener('click', closeDrawerFunc);
            overlay.addEventListener('click', closeDrawerFunc);

            // Close drawer on escape key
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && drawer.classList.contains('active')) {
                    closeDrawerFunc();
                }
            });
        }

        // AUTOMATIC DATA LOADING FUNCTION
        async function loadDataFromJSON() {
            try {
                document.getElementById('data-load-status').textContent = 'Loading from path.json...';
                
                // Simulate loading data (in a real app, you'd fetch this from a file)
                setTimeout(() => {
                    // Mock data for demonstration
                    CAMPUS_POINTS = {
                        "Laboratory": { x: -14.6737, y: 1.0284, z: 0.9795 },
                        "Tennis Park": { x: -12.0075, y: 0.4986, z: 0.5129 },
                        "BasketBall Court": { x: -19.9652, y: 0.4738, z: -8.9737 },
                        "CRIM": { x: -19.3745, y: 0.8704, z: -5.8635 },
                        "room_309": { x: -18.5058, y: 1.0101, z: 0.8616 },
                        "room_308": { x: -17.644, y: 1.0101, z: 0.8687 },
                        "room_306": { x: -16.6467, y: 1.0101, z: 0.9252 },
                        "room_307": { x: -17.1184, y: 1.0101, z: 0.9214 },
                        "room_304": { x: -14.8141, y: 1.0101, z: 0.9113 },
                        "room_303": { x: -14.1353, y: 1.0101, z: 0.9035 },
                        "room_301": { x: -12.6236, y: 1.0101, z: 0.9404 },
                        "room_302": { x: -13.3405, y: 1.0101, z: 0.9308 },
                        "multimedia_room": { x: -17.9743, y: 0.7638, z: 0.9431 },
                        "multimedia_lab": { x: -17.2209, y: 0.7638, z: 0.9364 },
                        "lab_3": { x: -16.525, y: 0.7638, z: 0.948 },
                        "speech": { x: -15.4037, y: 0.7638, z: 0.9398 },
                        "lab_2": { x: -13.6121, y: 0.7638, z: 0.9533 },
                        "lab_1": { x: -12.6305, y: 0.7638, z: 0.9166 },
                        "gate_1": { x: -9.9937, y: 0.4945, z: 2.8115 },
                        "registrar": { x: -10.0799, y: 0.4951, z: 1.2382 },
                        "tennis_court": { x: -13.7022, y: 0.4986, z: 0.4928 },
                        "faculty": { x: -14.4935, y: 0.4952, z: 0.9129 },
                        "dean_office": { x: -14.7936, y: 0.4952, z: 0.9106 },
                        "conferrence_room": { x: -15.4665, y: 0.5027, z: 0.9818 },
                        "basketball_court": { x: -19.4388, y: 0.4738, z: -8.8111 }
                    };
                    
                    // Mock paths with lookout points
                    PREDEFINED_PATHS = {
                        "1_2": {
                            path: [
                                { x: -14.6737, y: 1.0284, z: 0.9795 },
                                { x: -13.5000, y: 0.8000, z: 0.7500 },
                                { x: -12.0075, y: 0.4986, z: 0.5129 }
                            ],
                            lookout: { x: -13.0000, y: 1.5000, z: 0.6000 }
                        },
                        "2_3": {
                            path: [
                                { x: -12.0075, y: 0.4986, z: 0.5129 },
                                { x: -15.0000, y: 0.4800, z: -2.0000 },
                                { x: -17.5000, y: 0.4750, z: -5.5000 },
                                { x: -19.9652, y: 0.4738, z: -8.9737 }
                            ],
                            lookout: { x: -15.5000, y: 1.8000, z: -3.0000 }
                        }
                    };
                    
                    const locationCount = Object.keys(CAMPUS_POINTS).length;
                    const pathCount = Object.keys(PREDEFINED_PATHS).length;
                    
                    document.getElementById('data-load-status').textContent = 'Successfully loaded!';
                    document.getElementById('loaded-location-count').textContent = locationCount;
                    document.getElementById('loaded-path-count').textContent = pathCount;
                    
                    // Update UI with loaded data
                    updatePathList();
                    updateLocationDropdowns();
                    addCampusPointMarkers();
                    resetPersonToFirstLocation();
                    
                    // Show success message
                    const loadStatus = document.getElementById('load-status');
                    loadStatus.style.background = 'rgba(30, 50, 30, 0.7)';
                    loadStatus.style.borderLeftColor = '#00ff00';
                    
                    console.log('✅ Loaded mock data for demonstration');
                }, 1000);
                
            } catch (error) {
                console.error('❌ Error loading data:', error);
                document.getElementById('data-load-status').textContent = 'Failed to load - using defaults';
                
                // Use the provided locations as fallback
                CAMPUS_POINTS = {
                    "Laboratory": { x: -14.6737, y: 1.0284, z: 0.9795 },
                    "Tennis Park": { x: -12.0075, y: 0.4986, z: 0.5129 }
                };
                
                document.getElementById('loaded-location-count').textContent = Object.keys(CAMPUS_POINTS).length;
                document.getElementById('loaded-path-count').textContent = '0';
                
                // Show error status
                const loadStatus = document.getElementById('load-status');
                loadStatus.classList.add('error');
                
                // Still update UI with default data
                updateLocationDropdowns();
                addCampusPointMarkers();
                resetPersonToFirstLocation();
            }
        }

        // AUTO CAMERA MOVEMENT TO POINT A WHEN BOTH POINTS SELECTED
        function moveCameraToLocation(locationName) {
            if (!CAMPUS_POINTS[locationName]) return;
            
            const point = CAMPUS_POINTS[locationName];
            
            // Calculate optimal camera position (elevated and at an angle)
            const offset = { x: 3, y: 2, z: 3 };
            const cameraPosition = [
                point.x + offset.x,
                point.y + offset.y,
                point.z + offset.z
            ];
            
            // Target the actual point
            const target = [point.x, point.y, point.z];
            
            console.log(`🎯 Moving camera to ${locationName} at:`, point);
            
            // Animate camera movement
            animateCamera(cameraPosition, target, 1500);
        }

        // Enhanced camera animation function
        function animateCamera(targetPosition, targetLookAt, duration = 1000) {
            const startPosition = camera.position.clone();
            const startTarget = controls.target.clone();
            const endPosition = new THREE.Vector3(...targetPosition);
            const endTarget = new THREE.Vector3(...targetLookAt);
            const startTime = Date.now();
            
            function updateCamera() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                // Smooth easing function
                const ease = progress < 0.5
                    ? 4 * progress * progress * progress
                    : 1 - Math.pow(-2 * progress + 2, 3) / 2;
                
                camera.position.lerpVectors(startPosition, endPosition, ease);
                controls.target.lerpVectors(startTarget, endTarget, ease);
                controls.update();
                
                if (progress < 1) {
                    requestAnimationFrame(updateCamera);
                }
            }
            
            requestAnimationFrame(updateCamera);
        }

        // CHECK IF BOTH POINTS ARE SELECTED AND TRIGGER AUTO ACTIONS
        function checkAutoActions() {
            const notification = document.getElementById('auto-camera-notification');
            
            if (selectedFromPoint && selectedToPoint) {
                // Show notification
                notification.style.display = 'block';
                
                // Highlight the dropdowns
                document.getElementById('from-dropdown').querySelector('.dropdown-header').classList.add('selected');
                document.getElementById('to-dropdown').querySelector('.dropdown-header').classList.add('selected');
                
                // Auto move camera to starting point (Point A)
                setTimeout(() => {
                    moveCameraToLocation(selectedFromPoint);
                    console.log(`🚀 Auto-moved camera to start point: ${selectedFromPoint}`);
                }, 500);
                
            } else {
                // Hide notification
                notification.style.display = 'none';
                
                // Remove highlights
                document.getElementById('from-dropdown').querySelector('.dropdown-header').classList.remove('selected');
                document.getElementById('to-dropdown').querySelector('.dropdown-header').classList.remove('selected');
            }
        }

        // UPDATE LOCATION DROPDOWNS WITH LOADED DATA AND AUTO-CAMERA FUNCTIONALITY
        function updateLocationDropdowns() {
            // Clear existing dropdowns
            const fromOptions = document.getElementById('from-dropdown-options');
            const toOptions = document.getElementById('to-dropdown-options');
            
            fromOptions.innerHTML = '';
            toOptions.innerHTML = '';
            
            const locationNames = Object.keys(CAMPUS_POINTS).sort(); // Sort alphabetically
            
            locationNames.forEach(locationName => {
                // From dropdown
                const fromOption = document.createElement('div');
                fromOption.className = 'dropdown-option';
                fromOption.textContent = locationName;
                fromOption.dataset.value = locationName;
                fromOption.addEventListener('click', () => {
                    document.querySelectorAll('#from-dropdown .dropdown-option').forEach(opt => {
                        opt.classList.remove('selected');
                    });
                    fromOption.classList.add('selected');
                    document.getElementById('from-dropdown-text').textContent = locationName;
                    selectedFromPoint = locationName;
                    document.getElementById('from-dropdown').classList.remove('open');
                    
                    // CHECK FOR AUTO ACTIONS
                    checkAutoActions();
                });
                fromOptions.appendChild(fromOption);
                
                // To dropdown
                const toOption = document.createElement('div');
                toOption.className = 'dropdown-option';
                toOption.textContent = locationName;
                toOption.dataset.value = locationName;
                toOption.addEventListener('click', () => {
                    document.querySelectorAll('#to-dropdown .dropdown-option').forEach(opt => {
                        opt.classList.remove('selected');
                    });
                    toOption.classList.add('selected');
                    document.getElementById('to-dropdown-text').textContent = locationName;
                    selectedToPoint = locationName;
                    document.getElementById('to-dropdown').classList.remove('open');
                    
                    // CHECK FOR AUTO ACTIONS
                    checkAutoActions();
                });
                toOptions.appendChild(toOption);
            });
        }

        // RESET PERSON TO FIRST LOADED LOCATION
        function resetPersonToFirstLocation() {
            if (personModel && Object.keys(CAMPUS_POINTS).length > 0) {
                const firstLocationName = Object.keys(CAMPUS_POINTS)[0];
                const firstPoint = CAMPUS_POINTS[firstLocationName];
                personModel.position.set(firstPoint.x, firstPoint.y, firstPoint.z);
                document.getElementById('person-height').textContent = firstPoint.y.toFixed(2);
            }
        }

        // SHOW ALL PATHS FUNCTION
        function showAllPaths() {
            // Clear existing path visualizations
            allPathLines.forEach(line => scene.remove(line));
            allPathLines = [];

            if (Object.keys(PREDEFINED_PATHS).length === 0) {
                alert('No paths loaded to display');
                return;
            }

            // Create visualization for each path
            Object.entries(PREDEFINED_PATHS).forEach(([pathId, pathData], index) => {
                const pathCoordinates = pathData.path.map(point => 
                    new THREE.Vector3(point.x, point.y + 0.02, point.z)
                );

                if (pathCoordinates.length > 1) {
                    const curve = new THREE.CatmullRomCurve3(pathCoordinates);
                    const tubeGeometry = new THREE.TubeGeometry(curve, pathCoordinates.length * 2, 0.015, 8, false);
                    
                    // Use different colors for different paths
                    const colors = [0x00ff00, 0x0000ff, 0xffff00, 0xff00ff, 0x00ffff, 0xffa500];
                    const color = colors[index % colors.length];
                    
                    const tubeMaterial = new THREE.MeshBasicMaterial({ 
                        color: color,
                        transparent: true,
                        opacity: 0.6
                    });
                    
                    const pathLine = new THREE.Mesh(tubeGeometry, tubeMaterial);
                    pathLine.userData = { isAllPathsVisualization: true, pathId: pathId };
                    scene.add(pathLine);
                    allPathLines.push(pathLine);
                }
                
                // Add lookout indicator if it exists
                if (pathData.lookout) {
                    const lookout = pathData.lookout;
                    const lookoutGeometry = new THREE.SphereGeometry(0.06, 8, 6);
                    const lookoutMaterial = new THREE.MeshBasicMaterial({ 
                        color: 0xff00ff,
                        transparent: true,
                        opacity: 0.9
                    });
                    const lookoutMarker = new THREE.Mesh(lookoutGeometry, lookoutMaterial);
                    lookoutMarker.position.set(lookout.x, lookout.y + 0.05, lookout.z);
                    lookoutMarker.userData = { isLookout: true, pathId: pathId };
                    scene.add(lookoutMarker);
                    allPathLines.push(lookoutMarker);
                    
                    // Add text label
                    const canvas = document.createElement('canvas');
                    const context = canvas.getContext('2d');
                    canvas.width = 256;
                    canvas.height = 64;
                    context.fillStyle = '#ffffff';
                    context.font = '16px Arial';
                    context.textAlign = 'center';
                    context.fillText(`Lookout: ${pathId}`, 128, 40);

                    const texture = new THREE.CanvasTexture(canvas);
                    const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
                    const sprite = new THREE.Sprite(spriteMaterial);
                    sprite.position.set(lookout.x, lookout.y + 0.3, lookout.z);
                    sprite.scale.set(0.6, 0.15, 1);
                    sprite.userData = { isLookoutLabel: true, pathId: pathId };
                    scene.add(sprite);
                    allPathLines.push(sprite);
                }
            });

            console.log(`🎨 Displaying ${allPathLines.length} paths and lookouts`);
            alert(`Displaying ${Object.keys(PREDEFINED_PATHS).length} loaded paths with lookouts`);
        }

        // Create person model
        function createPersonModel() {
            const personGroup = new THREE.Group();
            
            // Body
            const bodyGeometry = new THREE.CylinderGeometry(0.03, 0.04, 0.12, 8);
            const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0x4169E1 });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.06;
            personGroup.add(body);
            
            // Head
            const headGeometry = new THREE.SphereGeometry(0.025, 8, 6);
            const headMaterial = new THREE.MeshLambertMaterial({ color: 0xFFDBB5 });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 0.145;
            personGroup.add(head);
            
            // Arms
            const armGeometry = new THREE.CylinderGeometry(0.008, 0.008, 0.08, 6);
            const armMaterial = new THREE.MeshLambertMaterial({ color: 0xFFDBB5 });
            
            const leftArm = new THREE.Mesh(armGeometry, armMaterial);
            leftArm.position.set(-0.045, 0.08, 0);
            leftArm.rotation.z = 0.3;
            personGroup.add(leftArm);
            
            const rightArm = new THREE.Mesh(armGeometry, armMaterial);
            rightArm.position.set(0.045, 0.08, 0);
            rightArm.rotation.z = -0.3;
            personGroup.add(rightArm);
            
            // Legs
            const legGeometry = new THREE.CylinderGeometry(0.01, 0.01, 0.08, 6);
            const legMaterial = new THREE.MeshLambertMaterial({ color: 0x2F4F4F });
            
            const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
            leftLeg.position.set(-0.015, -0.04, 0);
            personGroup.add(leftLeg);
            
            const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
            rightLeg.position.set(0.015, -0.04, 0);
            personGroup.add(rightLeg);
            
            // Position will be set after loading data
            personGroup.position.set(0, 0, 0);
            
            return personGroup;
        }

        // Initialize scene
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0c0c1a);
            scene.fog = new THREE.Fog(0x0c0c1a, 10, 50);
            
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(...COORDINATES.DEFAULT.position);
            
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, logarithmicDepthBuffer: true });
            
            const container = document.getElementById('canvas-container');
            renderer.setSize(container.offsetWidth, container.offsetHeight);
            renderer.shadowMap.enabled = false;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            container.appendChild(renderer.domElement);
            
            const gridHelper = new THREE.GridHelper(40, 20, 0x444466, 0x222244);
            gridHelper.position.y = -0.01;
            scene.add(gridHelper);
            
            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 1.0);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 2.0);
            directionalLight.position.set(20, 30, 20);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);
            
            const fillLight = new THREE.DirectionalLight(0xffffff, 1.5);
            fillLight.position.set(-20, 20, 20);
            scene.add(fillLight);
            
            const backLight = new THREE.DirectionalLight(0xffffff, 1.0);
            backLight.position.set(10, 20, -20);
            scene.add(backLight);
            
            const topLight = new THREE.DirectionalLight(0xffffff, 1.5);
            topLight.position.set(0, 50, 0);
            scene.add(topLight);
            
            // Controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = false;
            controls.maxDistance = 150;
            controls.minDistance = 2;
            controls.maxPolarAngle = Math.PI / 1.5;
            
            controls.target.set(...COORDINATES.DEFAULT.target);
            controls.update();
            
            window.addEventListener('resize', onWindowResize, false);
            
            initDrawer();
            initUI();
            
            personModel = createPersonModel();
            scene.add(personModel);
            
            // Add click listener for path recording
            container.addEventListener('click', onMouseClick, false);
            
            // Initialize fly controls
            initFlyControls();
            
            // LOAD DATA AUTOMATICALLY ON STARTUP
            loadDataFromJSON();
            
            loadModel();
        }
        
        // Initialize fly mode controls
        function initFlyControls() {
            flyControls = new THREE.PointerLockControls(camera, document.body);
            
            // Event listeners for fly mode
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            
            // Exit fly mode button
            document.getElementById('exit-fly-mode').addEventListener('click', exitFlyMode);
        }
        
        // Handle key down for fly mode
        function onKeyDown(event) {
            if (!isFlyMode) return;
            
            switch (event.code) {
                case 'ArrowUp':
                case 'KeyW':
                    moveForward = true;
                    break;
                case 'ArrowLeft':
                case 'KeyA':
                    moveLeft = true;
                    break;
                case 'ArrowDown':
                case 'KeyS':
                    moveBackward = true;
                    break;
                case 'ArrowRight':
                case 'KeyD':
                    moveRight = true;
                    break;
                case 'Space':
                    moveUp = true;
                    break;
                case 'ShiftLeft':
                case 'ShiftRight':
                    moveDown = true;
                    break;
                // Record point in fly mode
                case 'KeyP':
                    if (isRecording) {
                        recordPointAtCenter();
                    }
                    break;
                // Undo last point in fly mode
                case 'KeyU':
                    if (isRecording) {
                        undoLastPoint();
                    }
                    break;
            }
        }
        
        // Record point at center of screen in fly mode
        function recordPointAtCenter() {
            if (!isRecording) return;
            
            // Create a ray from the camera through the center of the screen
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            
            // Get all meshes for intersection
            const intersectObjects = [];
            if (model) {
                model.traverse((child) => {
                    if (child.isMesh) {
                        intersectObjects.push(child);
                    }
                });
            }
            
            // Add ground plane
            const planeGeometry = new THREE.PlaneGeometry(100, 100);
            const planeMaterial = new THREE.MeshBasicMaterial({ visible: false });
            const plane = new THREE.Mesh(planeGeometry, planeMaterial);
            plane.rotation.x = -Math.PI / 2;
            plane.position.y = 0;
            intersectObjects.push(plane);
            
            const intersects = raycaster.intersectObjects(intersectObjects);
            
            if (intersects.length > 0) {
                const point = intersects[0].point;
                addPathPoint(point);
            }
        }
        
        // Handle key up for fly mode
        function onKeyUp(event) {
            if (!isFlyMode) return;
            
            switch (event.code) {
                case 'ArrowUp':
                case 'KeyW':
                    moveForward = false;
                    break;
                case 'ArrowLeft':
                case 'KeyA':
                    moveLeft = false;
                    break;
                case 'ArrowDown':
                case 'KeyS':
                    moveBackward = false;
                    break;
                case 'ArrowRight':
                case 'KeyD':
                    moveRight = false;
                    break;
                case 'Space':
                    moveUp = false;
                    break;
                case 'ShiftLeft':
                case 'ShiftRight':
                    moveDown = false;
                    break;
            }
        }
        
        // Enter fly mode
        function enterFlyMode() {
            if (isFlyMode) return;
            
            isFlyMode = true;
            document.getElementById('fly-mode-status').textContent = 'Fly Mode: Active';
            
            // Hide UI elements
            document.getElementById('controls-drawer').style.display = 'none';
            document.getElementById('burger-menu').style.display = 'none';
            
            // Show fly controls UI
            document.getElementById('fly-controls').classList.add('active');
            
            // Enable pointer lock
            document.body.requestPointerLock = document.body.requestPointerLock || document.body.mozRequestPointerLock || document.body.webkitRequestPointerLock;
            document.body.requestPointerLock();
            
            // Enable fly controls
            flyControls.lock();
            flyControls.enabled = true;
            
            // Set camera position to a good starting point
            camera.position.set(0, 3, 0);
            
            console.log('🚀 Entered Fly Mode');
        }
        
        // Exit fly mode
        function exitFlyMode() {
            if (!isFlyMode) return;
            
            isFlyMode = false;
            document.getElementById('fly-mode-status').textContent = 'Fly Mode: Inactive';
            
            // Show UI elements
            document.getElementById('controls-drawer').style.display = '';
            document.getElementById('burger-menu').style.display = '';
            
            // Hide fly controls UI
            document.getElementById('fly-controls').classList.remove('active');
            
            // Disable pointer lock
            document.exitPointerLock = document.exitPointerLock || document.mozExitPointerLock || document.webkitExitPointerLock;
            document.exitPointerLock();
            
            // Disable fly controls
            flyControls.unlock();
            flyControls.enabled = false;
            
            // Reset movement flags
            moveForward = false;
            moveBackward = false;
            moveLeft = false;
            moveRight = false;
            moveUp = false;
            moveDown = false;
            
            // Reset camera to default position
            animateCamera(COORDINATES.DEFAULT.position, COORDINATES.DEFAULT.target, 1000);
            
            console.log('🛑 Exited Fly Mode');
        }

        // Initialize UI
        function initUI() {
            initModeToggle();
            initDropdown();
            initPersonControls();
            initPathEditor();
            initNavigationControls();
            
            // Add fly mode button listener (in editor panel)
            document.getElementById('fly-mode').addEventListener('click', enterFlyMode);
        }

        // INITIALIZE NAVIGATION CONTROLS
        function initNavigationControls() {
            document.getElementById('generate-path').addEventListener('click', generatePath);
            document.getElementById('clear-path').addEventListener('click', clearPath);
            
            // Initialize dropdown headers
            document.getElementById('from-dropdown').querySelector('.dropdown-header').addEventListener('click', () => {
                document.querySelectorAll('.dropdown').forEach(d => {
                    if (d.id !== 'from-dropdown') d.classList.remove('open');
                });
                document.getElementById('from-dropdown').classList.toggle('open');
            });
            
            document.getElementById('to-dropdown').querySelector('.dropdown-header').addEventListener('click', () => {
                document.querySelectorAll('.dropdown').forEach(d => {
                    if (d.id !== 'to-dropdown') d.classList.remove('open');
                });
                document.getElementById('to-dropdown').classList.toggle('open');
            });
        }

        // Mode toggle
        function initModeToggle() {
            const navigateBtn = document.getElementById('navigate-mode');
            const editBtn = document.getElementById('edit-mode');
            const navigationPanel = document.getElementById('navigation-panel');
            const editorPanel = document.getElementById('editor-panel');

            navigateBtn.addEventListener('click', () => {
                isEditMode = false;
                navigateBtn.classList.add('active');
                editBtn.classList.remove('active');
                navigationPanel.style.display = 'block';
                editorPanel.style.display = 'none';
                document.getElementById('canvas-container').style.cursor = 'default';
                document.body.classList.remove('recording');
                
                // Exit fly mode when switching to navigation
                if (isFlyMode) {
                    exitFlyMode();
                }
            });

            editBtn.addEventListener('click', () => {
                isEditMode = true;
                editBtn.classList.add('active');
                navigateBtn.classList.remove('active');
                navigationPanel.style.display = 'none';
                editorPanel.style.display = 'block';
            });
        }

        // Path editor initialization
        function initPathEditor() {
            document.getElementById('start-recording').addEventListener('click', startRecording);
            document.getElementById('save-path').addEventListener('click', savePath);
            document.getElementById('clear-current').addEventListener('click', clearCurrentPath);
            document.getElementById('undo-point').addEventListener('click', undoLastPoint);
            document.getElementById('export-paths').addEventListener('click', exportPaths);
            document.getElementById('import-paths').addEventListener('click', () => {
                document.getElementById('file-input').click();
            });
            document.getElementById('file-input').addEventListener('change', importPaths);
            
            // Look Up button
            document.getElementById('look-up').addEventListener('click', showLookUp);
            
            // Data management buttons
            document.getElementById('reload-data').addEventListener('click', loadDataFromJSON);
            document.getElementById('show-all-paths').addEventListener('click', showAllPaths);
        }

        // Show Look Up function
        function showLookUp() {
            if (Object.keys(savedPaths).length === 0) {
                alert('No paths to look up');
                return;
            }
            
            // Create a message with all saved paths
            let message = "Saved Paths:\n\n";
            Object.keys(savedPaths).forEach(pathName => {
                const pointCount = savedPaths[pathName].length;
                message += `• ${pathName} (${pointCount} points)\n`;
            });
            
            alert(message);
        }

        // Mouse click handler for path recording
        function onMouseClick(event) {
            if (!isEditMode || !isRecording) return;

            const rect = event.target.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            // Get all meshes for intersection
            const intersectObjects = [];
            if (model) {
                model.traverse((child) => {
                    if (child.isMesh) {
                        intersectObjects.push(child);
                    }
                });
            }

            // Add ground plane
            const planeGeometry = new THREE.PlaneGeometry(100, 100);
            const planeMaterial = new THREE.MeshBasicMaterial({ visible: false });
            const plane = new THREE.Mesh(planeGeometry, planeMaterial);
            plane.rotation.x = -Math.PI / 2;
            plane.position.y = 0;
            intersectObjects.push(plane);

            const intersects = raycaster.intersectObjects(intersectObjects);

            if (intersects.length > 0) {
                const point = intersects[0].point;
                addPathPoint(point);
            }
        }

        // Path recording functions
        function startRecording() {
            const pathName = document.getElementById('path-name').value.trim();
            if (!pathName) {
                alert('Please enter a path name first');
                return;
            }

            isRecording = !isRecording;
            const btn = document.getElementById('start-recording');
            
            if (isRecording) {
                btn.textContent = 'Stop Recording';
                btn.classList.add('active');
                document.getElementById('canvas-container').style.cursor = 'crosshair';
                document.getElementById('recording-status').textContent = 'Recording';
                
                // Automatically enter fly mode when starting recording
                if (!isFlyMode) {
                    enterFlyMode();
                }
            } else {
                btn.textContent = 'Start Recording';
                btn.classList.remove('active');
                document.getElementById('canvas-container').style.cursor = 'default';
                document.getElementById('recording-status').textContent = 'Stopped';
                document.body.classList.remove('recording');
                
                // Automatically exit fly mode when stopping recording
                if (isFlyMode) {
                    exitFlyMode();
                }
            }
        }

        function addPathPoint(point) {
            const pathPoint = {
                x: parseFloat(point.x.toFixed(4)),
                y: parseFloat(point.y.toFixed(4)),
                z: parseFloat(point.z.toFixed(4))
            };

            currentRecordingPath.push(pathPoint);

            // Add visual marker
            const geometry = new THREE.SphereGeometry(0.03, 8, 6);
            const material = new THREE.MeshBasicMaterial({ 
                color: 0x00ff00,
                transparent: true,
                opacity: 0.8
            });

            const marker = new THREE.Mesh(geometry, material);
            marker.position.set(pathPoint.x, pathPoint.y + 0.03, pathPoint.z);
            marker.userData = { isRecordingMarker: true };
            scene.add(marker);
            recordingMarkers.push(marker);

            // Add connecting line if more than one point
            if (currentRecordingPath.length > 1) {
                updateRecordingPath();
            }

            document.getElementById('point-count').textContent = currentRecordingPath.length;
        }

        function updateRecordingPath() {
            // Remove existing recording line
            const existingLine = scene.children.find(child => child.userData.isRecordingLine);
            if (existingLine) {
                scene.remove(existingLine);
            }

            if (currentRecordingPath.length < 2) return;

            // Create new line
            const points = currentRecordingPath.map(p => new THREE.Vector3(p.x, p.y + 0.02, p.z));
            const curve = new THREE.CatmullRomCurve3(points);
            const tubeGeometry = new THREE.TubeGeometry(curve, points.length * 2, 0.015, 8, false);
            const tubeMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x00ff00,
                transparent: true,
                opacity: 0.7
            });

            const pathLine = new THREE.Mesh(tubeGeometry, tubeMaterial);
            pathLine.userData = { isRecordingLine: true };
            scene.add(pathLine);
        }

        function savePath() {
            const pathName = document.getElementById('path-name').value.trim();
            if (!pathName) {
                alert('Please enter a path name');
                return;
            }

            if (currentRecordingPath.length < 2) {
                alert('Path must have at least 2 points');
                return;
            }

            // Save both path and lookout point
            savedPaths[pathName] = [...currentRecordingPath];
            PREDEFINED_PATHS[pathName] = { 
                path: [...currentRecordingPath],
                lookout: calculateLookoutPoint()
            };
            
            updatePathList();
            clearCurrentPath();
            document.getElementById('path-name').value = '';
            
            // Update loaded path count
            document.getElementById('loaded-path-count').textContent = Object.keys(PREDEFINED_PATHS).length;
            
            alert(`Path "${pathName}" saved with ${currentRecordingPath.length} points and lookout`);
        }
        
        // Calculate an elevated lookout point for the path
        function calculateLookoutPoint() {
            if (currentRecordingPath.length < 3) return null;
            
            // Find the middle point of the path
            const midIndex = Math.floor(currentRecordingPath.length / 2);
            const midPoint = currentRecordingPath[midIndex];
            
            // Calculate average height and add elevation
            const avgHeight = currentRecordingPath.reduce((sum, p) => sum + p.y, 0) / currentRecordingPath.length;
            const lookoutHeight = avgHeight + 1.5; // Add 1.5 units of elevation
            
            // Create lookout point at middle of path but elevated
            return {
                x: midPoint.x,
                y: lookoutHeight,
                z: midPoint.z
            };
        }

        function clearCurrentPath() {
            currentRecordingPath = [];
            recordingMarkers.forEach(marker => scene.remove(marker));
            recordingMarkers = [];
            
            const recordingLine = scene.children.find(child => child.userData.isRecordingLine);
            if (recordingLine) {
                scene.remove(recordingLine);
            }

            document.getElementById('point-count').textContent = '0';
        }

        function undoLastPoint() {
            if (currentRecordingPath.length === 0) return;

            currentRecordingPath.pop();
            const lastMarker = recordingMarkers.pop();
            if (lastMarker) {
                scene.remove(lastMarker);
            }

            updateRecordingPath();
            document.getElementById('point-count').textContent = currentRecordingPath.length;
        }

        function updatePathList() {
            const listContainer = document.getElementById('path-list');
            
            if (Object.keys(savedPaths).length === 0) {
                listContainer.innerHTML = '<p style="text-align: center; opacity: 0.6; padding: 20px;">No paths loaded</p>';
                return;
            }

            listContainer.innerHTML = '';
            
            Object.entries(savedPaths).forEach(([name, path]) => {
                const item = document.createElement('div');
                item.className = 'path-item';
                
                // Check if this path was loaded from JSON
                const isFromJSON = PREDEFINED_PATHS[name] && PREDEFINED_PATHS[name].path.length === path.length;
                const sourceIcon = isFromJSON ? '📁' : '✏️';
                
                item.innerHTML = `
                    <div>
                        <div style="font-weight: bold; color: #00dbde;">${sourceIcon} ${name}</div>
                        <div style="font-size: 0.8rem; opacity: 0.7;">${path.length} points ${isFromJSON ? '(from JSON)' : '(created)'}</div>
                    </div>
                    <button class="btn danger" onclick="deletePath('${name}')" style="padding: 4px 8px; margin: 0;">×</button>
                `;
                
                listContainer.appendChild(item);
            });
        }

        function deletePath(pathName) {
            if (confirm(`Delete path "${pathName}"?`)) {
                delete savedPaths[pathName];
                delete PREDEFINED_PATHS[pathName];
                updatePathList();
                document.getElementById('loaded-path-count').textContent = Object.keys(PREDEFINED_PATHS).length;
            }
        }

        function exportPaths() {
            if (Object.keys(savedPaths).length === 0) {
                alert('No paths to export');
                return;
            }

            // EXPORT IN YOUR JSON FORMAT
            const exportData = {
                version: "1.0",
                created: new Date().toISOString(),
                locations: {},
                paths: {}
            };

            // Add locations with IDs
            Object.entries(CAMPUS_POINTS).forEach(([locationName, coords], index) => {
                const locationId = LOCATION_ID_MAP[locationName] || (index + 1);
                exportData.locations[locationName] = {
                    id: locationId,
                    location: {
                        x: coords.x,
                        y: coords.y,
                        z: coords.z
                    }
                };
            });

            // Add paths
            Object.entries(savedPaths).forEach(([pathName, pathPoints]) => {
                exportData.paths[pathName] = {
                    path: pathPoints,
                    lookout: calculateLookoutPoint()
                };
            });

            const dataStr = JSON.stringify(exportData, null, 2);
            const blob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'path.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            console.log('Exported data:', exportData);
        }

        function importPaths(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);
                    
                    // Handle new JSON format
                    if (data.locations) {
                        Object.entries(data.locations).forEach(([locationName, locationData]) => {
                            CAMPUS_POINTS[locationName] = {
                                x: locationData.location.x,
                                y: locationData.location.y,
                                z: locationData.location.z
                            };
                            LOCATION_ID_MAP[locationName] = locationData.id;
                        });
                        updateLocationDropdowns();
                        addCampusPointMarkers();
                    }
                    
                    if (data.paths) {
                        Object.entries(data.paths).forEach(([pathId, pathData]) => {
                            if (pathData.path) {
                                savedPaths[pathId] = pathData.path;
                                PREDEFINED_PATHS[pathId] = {
                                    path: pathData.path,
                                    lookout: pathData.lookout
                                };
                            }
                        });
                        updatePathList();
                        document.getElementById('loaded-path-count').textContent = Object.keys(PREDEFINED_PATHS).length;
                        alert(`Imported ${Object.keys(data.paths).length} paths and ${Object.keys(data.locations || {}).length} locations`);
                    } else {
                        alert('Invalid file format');
                    }
                } catch (error) {
                    alert('Error reading file: ' + error.message);
                }
            };
            reader.readAsText(file);
        }

        // UPDATED NAVIGATION FUNCTIONS WITH ID SUPPORT
        function findPredefinedPath(from, to) {
            // Try ID-based paths first
            const fromId = LOCATION_ID_MAP[from];
            const toId = LOCATION_ID_MAP[to];
            
            if (fromId && toId) {
                // Try direct path (fromId_toId)
                const directPathId = `${fromId}_${toId}`;
                if (PREDEFINED_PATHS[directPathId]) {
                    console.log('✅ Found ID-based direct path:', directPathId);
                    return PREDEFINED_PATHS[directPathId].path;
                }
                
                // Try reverse path (toId_fromId)
                const reversePathId = `${toId}_${fromId}`;
                if (PREDEFINED_PATHS[reversePathId]) {
                    console.log('✅ Found ID-based reverse path:', reversePathId);
                    return [...PREDEFINED_PATHS[reversePathId].path].reverse();
                }
            }
            
            // Try name-based paths
            const directPath = `${from}-${to}`;
            if (PREDEFINED_PATHS[directPath]) {
                return PREDEFINED_PATHS[directPath].path;
            }

            const reversePath = `${to}-${from}`;
            if (PREDEFINED_PATHS[reversePath]) {
                return [...PREDEFINED_PATHS[reversePath].path].reverse();
            }

            return null;
        }

        function generatePath() {
            if (!selectedFromPoint || !selectedToPoint) {
                alert('Please select both start and end points');
                return;
            }
            
            if (selectedFromPoint === selectedToPoint) {
                alert('Start and end points cannot be the same');
                return;
            }
            
            clearPath();

            // First try to find predefined path
            const predefinedPath = findPredefinedPath(selectedFromPoint, selectedToPoint);
            
            if (predefinedPath) {
                // Use predefined path
                const pathCoordinates = predefinedPath.map(point => 
                    new THREE.Vector3(point.x, point.y + 0.02, point.z)
                );
                
                createPathVisualization(pathCoordinates);
                currentPath = pathCoordinates;
                document.getElementById('path-type').textContent = '✅ Using custom path';
                
                console.log('✅ Using predefined path:', selectedFromPoint, 'to', selectedToPoint);
            } else {
                // Fallback to simple direct path
                const startPoint = CAMPUS_POINTS[selectedFromPoint];
                const endPoint = CAMPUS_POINTS[selectedToPoint];
                
                if (!startPoint || !endPoint) {
                    alert('Location coordinates not found');
                    return;
                }
                
                const pathCoordinates = [
                    new THREE.Vector3(startPoint.x, startPoint.y + 0.02, startPoint.z),
                    new THREE.Vector3(endPoint.x, endPoint.y + 0.02, endPoint.z)
                ];
                
                createPathVisualization(pathCoordinates);
                currentPath = pathCoordinates;
                document.getElementById('path-type').textContent = '⚠️ Direct path (no custom path)';
                
                console.log('⚠️ Using direct path (no predefined path found)');
            }

            // MOVE CAMERA TO START POINT AFTER GENERATING PATH
            setTimeout(() => {
                moveCameraToLocation(selectedFromPoint);
            }, 200);
        }

        function createPathVisualization(pathCoordinates) {
            const curve = new THREE.CatmullRomCurve3(pathCoordinates);
            const tubeGeometry = new THREE.TubeGeometry(curve, pathCoordinates.length * 2, 0.02, 8, false);
            const tubeMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xff0000,
                transparent: true,
                opacity: 0.9
            });
            
            pathLine = new THREE.Mesh(tubeGeometry, tubeMaterial);
            scene.add(pathLine);
        }

        function clearPath() {
            isWalking = false;
            walkingProgress = 0;
            
            if (pathLine) {
                scene.remove(pathLine);
                pathLine = null;
            }
            
            // Clear all path visualizations
            allPathLines.forEach(line => scene.remove(line));
            allPathLines = [];
            
            currentPath = null;
            document.getElementById('walk-progress').textContent = '0%';
            document.getElementById('path-type').textContent = 'No path';
            
            // Clear auto-camera notification
            document.getElementById('auto-camera-notification').style.display = 'none';
        }

        // Add campus point markers
        function addCampusPointMarkers() {
            // Clear existing markers first
            const existingMarkers = scene.children.filter(child => child.userData.isMarker);
            existingMarkers.forEach(marker => scene.remove(marker));
            
            Object.entries(CAMPUS_POINTS).forEach(([name, point]) => {
                const geometry = new THREE.SphereGeometry(0.05, 8, 6);
                const material = new THREE.MeshBasicMaterial({ color: 0x00dbde, transparent: true, opacity: 0.8 });
                const marker = new THREE.Mesh(geometry, material);
                marker.position.set(point.x, point.y + 0.05, point.z);
                marker.userData = { name: name, isMarker: true };
                scene.add(marker);

                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 256;
                canvas.height = 64;
                context.fillStyle = '#ffffff';
                context.font = '16px Arial';
                context.textAlign = 'center';
                context.fillText(name, 128, 40);

                const texture = new THREE.CanvasTexture(canvas);
                const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
                const sprite = new THREE.Sprite(spriteMaterial);
                sprite.position.set(point.x, point.y + 0.2, point.z);
                sprite.scale.set(0.4, 0.1, 1);
                sprite.userData = { name: name, isMarker: true };
                scene.add(sprite);
            });
        }

        // Person controls
        function initPersonControls() {
            document.getElementById('walk-path').addEventListener('click', () => {
                if (currentPath && currentPath.length > 0) {
                    startWalking();
                } else {
                    alert('Please generate a path first!');
                }
            });
            
            document.getElementById('reset-person').addEventListener('click', () => {
                resetPerson();
            });
        }
        
        function startWalking() {
            if (!currentPath || currentPath.length === 0) return;
            
            isWalking = true;
            walkingProgress = 0;
            
            if (currentPath.length > 0) {
                personModel.position.copy(currentPath[0]);
            }
        }
        
        function resetPerson() {
            isWalking = false;
            walkingProgress = 0;
            
            const firstLocationName = Object.keys(CAMPUS_POINTS)[0];
            if (firstLocationName) {
                const firstPoint = CAMPUS_POINTS[firstLocationName];
                personModel.position.set(firstPoint.x, firstPoint.y, firstPoint.z);
                document.getElementById('walk-progress').textContent = '0%';
                document.getElementById('person-height').textContent = firstPoint.y.toFixed(2);
            }
        }

        // Load model
        function loadModel() {
            const loader = new THREE.GLTFLoader();
            const modelUrl = 'nwssu.glb';
            
            loader.load(
                modelUrl,
                (gltf) => {
                    model = gltf.scene;
                    
                    const bbox = new THREE.Box3().setFromObject(model);
                    const size = bbox.getSize(new THREE.Vector3());
                    
                    const maxDimension = Math.max(size.x, size.y, size.z);
                    const scale = 50 / maxDimension;
                    model.scale.setScalar(scale);
                    
                    model.traverse((child) => {
                        if (child.isMesh) {
                            child.castShadow = true;
                            child.receiveShadow = true;
                        }
                    });
                    
                    scene.add(model);
                    controls.target.set(0, 0, 0);
                    controls.update();
                    
                    document.getElementById('loading').classList.add('hidden');
                    renderer.render(scene, camera);
                },
                (xhr) => {
                    const percent = Math.round((xhr.loaded / xhr.total) * 100);
                },
                (error) => {
                    document.getElementById('loading').classList.add('hidden');
                    createPlaceholderModel();
                }
            );
        }
        
        // Camera dropdown
        function initDropdown() {
            const dropdown = document.getElementById('dropdown');
            const dropdownOptions = document.getElementById('dropdown-options');
            const dropdownText = document.getElementById('dropdown-text');
            
            Object.keys(COORDINATES).forEach(key => {
                const option = document.createElement('div');
                option.className = 'dropdown-option';
                option.textContent = key;
                option.dataset.key = key;
                
                option.addEventListener('click', () => {
                    document.querySelectorAll('#dropdown .dropdown-option').forEach(opt => {
                        opt.classList.remove('selected');
                    });
                    option.classList.add('selected');
                    
                    dropdownText.textContent = key;
                    animateCameraToCoordinate(key);
                    dropdown.classList.remove('open');
                });
                
                dropdownOptions.appendChild(option);
            });
            
            dropdown.querySelector('.dropdown-header').addEventListener('click', () => {
                dropdown.classList.toggle('open');
            });
            
            document.addEventListener('click', (e) => {
                if (!dropdown.contains(e.target)) {
                    dropdown.classList.remove('open');
                }
            });
        }
        
        function animateCameraToCoordinate(coordinateKey) {
            const coordinate = COORDINATES[coordinateKey];
            if (!coordinate) return;
            
            const endPosition = new THREE.Vector3(...coordinate.position);
            const endTarget = new THREE.Vector3(...coordinate.target);
            
            animateCamera([endPosition.x, endPosition.y, endPosition.z], [endTarget.x, endTarget.y, endTarget.z], 1000);
        }
        
        function onWindowResize() {
            camera.aspect = document.getElementById('canvas-container').offsetWidth / document.getElementById('canvas-container').offsetHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(document.getElementById('canvas-container').offsetWidth, document.getElementById('canvas-container').offsetHeight);
        }
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            // Update fly mode movement
            if (isFlyMode && flyControls.enabled) {
                const delta = 0.1;
                
                if (moveForward) {
                    flyControls.moveForward(delta);
                }
                if (moveBackward) {
                    flyControls.moveForward(-delta);
                }
                if (moveLeft) {
                    flyControls.moveRight(-delta);
                }
                if (moveRight) {
                    flyControls.moveRight(delta);
                }
                if (moveUp) {
                    camera.position.y += delta;
                }
                if (moveDown) {
                    camera.position.y -= delta;
                }
            }
            
            // Animate person walking
            if (isWalking && currentPath && currentPath.length > 1) {
                walkingProgress += 0.005;
                
                if (walkingProgress >= 1) {
                    walkingProgress = 1;
                    isWalking = false;
                }
                
                const totalLength = currentPath.length - 1;
                const scaledProgress = walkingProgress * totalLength;
                const index = Math.floor(scaledProgress);
                const fraction = scaledProgress - index;
                
                if (index < currentPath.length - 1) {
                    const start = currentPath[index];
                    const end = currentPath[index + 1];
                    
                    personModel.position.lerpVectors(start, end, fraction);
                    
                    const direction = new THREE.Vector3().subVectors(end, start).normalize();
                    if (direction.length() > 0) {
                        personModel.lookAt(personModel.position.clone().add(direction));
                    }
                    
                    const bobOffset = Math.sin(Date.now() * 0.01) * 0.01;
                    personModel.position.y += bobOffset;
                    
                    document.getElementById('walk-progress').textContent = Math.round(walkingProgress * 100) + '%';
                    document.getElementById('person-height').textContent = personModel.position.y.toFixed(2);
                }
            }
            
            if (!isFlyMode) {
                controls.update();
            }
            renderer.render(scene, camera);
        }
        
        // Close dropdowns when clicking outside
        document.addEventListener('click', (e) => {
            document.querySelectorAll('.dropdown').forEach(dropdown => {
                if (!dropdown.contains(e.target)) {
                    dropdown.classList.remove('open');
                }
            });
        });

        // Make deletePath available globally
        window.deletePath = deletePath;
        
        init();
        animate();
    </script>
</body>
</html>